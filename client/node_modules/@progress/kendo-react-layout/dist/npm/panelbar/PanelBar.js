"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var PropTypes = require("prop-types");
var PanelBarItem_1 = require("./PanelBarItem");
var util_1 = require("./util");
var selectionService_1 = require("./services/selectionService");
var navigationService_1 = require("./services/navigationService");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var PanelBar = /** @class */ (function (_super) {
    __extends(PanelBar, _super);
    function PanelBar(props) {
        var _this = _super.call(this, props) || this;
        _this._element = null;
        /**
         * @hidden
         */
        _this.handleSelect = function (event) {
            var state = __assign({}, _this.state, { selected: _this.selected });
            _this._selectionService.select(event.uniquePrivateKey, util_1.renderChildren(_this.props.animation, state, _this.handleSelect, _this.props.children), state.expanded);
            _this._selectionService.focus(event.uniquePrivateKey, 0, util_1.renderChildren(_this.props.animation, state, _this.handleSelect, _this.props.children));
        };
        /**
         * @hidden
         */
        _this.onSelect = function (child, expanded) {
            _this.setState({ selected: child.props.uniquePrivateKey, expanded: expanded }, function () {
                if (_this.props.onSelect) {
                    _this.props.onSelect.call(undefined, {
                        target: child,
                        action: 'select'
                    });
                }
            });
        };
        /**
         * @hidden
         */
        _this.onFocus = function (child) {
            _this.activeDescendant = child.props.id;
            _this.setState({ focused: child.props.uniquePrivateKey });
        };
        /**
         * @hidden
         */
        _this.onNavigate = function (action) {
            var state = __assign({}, _this.state, { selected: _this.selected });
            switch (action) {
                case navigationService_1.NavigationAction.Previous:
                    _this._selectionService.focus(state.focused, -1, util_1.renderChildren(_this.props.animation, state, _this.handleSelect, _this.props.children));
                    break;
                case navigationService_1.NavigationAction.Next:
                    _this._selectionService.focus(state.focused, 1, util_1.renderChildren(_this.props.animation, state, _this.handleSelect, _this.props.children));
                    break;
                case navigationService_1.NavigationAction.Toggle:
                    _this._selectionService.select(state.focused, util_1.renderChildren(_this.props.animation, state, _this.handleSelect, _this.props.children), state.expanded);
                    break;
                default:
            }
        };
        _this.handleWrapperFocus = function () {
            clearTimeout(_this.nextTickId);
            if (!_this.state.wrapperFocused) {
                _this.setState({ wrapperFocused: true });
            }
        };
        _this.handleWrapperBlur = function () {
            _this.nextTick(function () {
                _this.setState({ wrapperFocused: false });
            });
        };
        _this.handleKeyDown = function (event) {
            var rtl = _this._element && (getComputedStyle(_this._element).direction === 'rtl') || false;
            var target = event.target, currentTarget = event.currentTarget;
            if (target === currentTarget) {
                _this._navigationService.navigate(event, rtl);
            }
        };
        _this.state = util_1.getInitialState(props, props.expandMode || 'multiple');
        _this._selectionService = new selectionService_1.default(_this.onSelect, _this.onFocus, _this.props.expandMode || 'multiple');
        _this._navigationService = new navigationService_1.default(_this.onNavigate);
        return _this;
    }
    Object.defineProperty(PanelBar.prototype, "selected", {
        get: function () {
            var _a = this.props.selected, selected = _a === void 0 ? this.state.selected : _a;
            return selected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    PanelBar.prototype.componentDidUpdate = function (prevProps) {
        var newProps = this.props;
        if (newProps.expandMode !== prevProps.expandMode) {
            this._selectionService.setExpandMode(newProps.expandMode);
        }
    };
    /**
     * @hidden
     */
    PanelBar.prototype.render = function () {
        var _this = this;
        var ariaProps = {
            'aria-activedescendant': this.activeDescendant
        };
        var state = __assign({}, this.state, { selected: this.selected });
        var children = util_1.renderChildren(this.props.animation, state, this.handleSelect, this.props.children);
        var className = kendo_react_common_1.classNames('k-widget', 'k-panelbar', this.props.className);
        return (React.createElement("div", __assign({ ref: function (div) { _this._element = div; }, dir: this.props.dir, role: 'tree', tabIndex: 0, onKeyDown: this.handleKeyDown, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, className: className, style: this.props.style }, ariaProps), children));
    };
    PanelBar.prototype.nextTick = function (f) {
        // XXX: use setTimeout due to async focus/blur events in IE, and missing relatedTarget prop.
        // XXX: https://github.com/facebook/react/issues/3751
        // Handles multiple focus events happening at the same time.
        clearTimeout(this.nextTickId);
        this.nextTickId = setTimeout(function () { return f(); });
    };
    /**
     * @hidden
     */
    PanelBar.propTypes = {
        animation: PropTypes.bool,
        children: function (props, propName) {
            var prop = props[propName];
            if (prop) {
                if (Array.isArray(prop)) {
                    for (var _i = 0, prop_1 = prop; _i < prop_1.length; _i++) {
                        var value = prop_1[_i];
                        if (!value.type || value.type !== PanelBarItem_1.default) {
                            return new Error('PanelBar children should be either PanelBarItem or Array of PanelBarItem.');
                        }
                    }
                }
                else {
                    if (prop.type !== PanelBarItem_1.default) {
                        return new Error('PanelBar child should be either PanelBarItem or Array of PanelBarItem.');
                    }
                }
            }
        },
        dir: PropTypes.string,
        selected: PropTypes.string,
        expanded: PropTypes.arrayOf(PropTypes.string),
        focused: PropTypes.string,
        expandMode: PropTypes.oneOf(['single', 'multiple']),
        className: PropTypes.string,
        onSelect: PropTypes.func,
        style: PropTypes.object
    };
    /**
     * @hidden
     */
    PanelBar.defaultProps = {
        expandMode: 'multiple',
        animation: true
    };
    return PanelBar;
}(React.Component));
exports.default = PanelBar;
//# sourceMappingURL=PanelBar.js.map