"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var PropTypes = require("prop-types");
var kendo_react_intl_1 = require("@progress/kendo-react-intl");
var kendo_charts_1 = require("@progress/kendo-charts");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var main_1 = require("./utils/main");
var dom_events_builder_1 = require("./events/dom-events-builder");
var chart_event_builder_1 = require("./events/chart-event-builder");
var dom_event_1 = require("./events/dom-event");
var theme_service_1 = require("./theming/theme-service");
var store_1 = require("./store/store");
var reducer_1 = require("./store/reducer");
var main_2 = require("./utils/main");
require("./defaults");
var Series_1 = require("./tooltip/Series");
var CrosshairContainer_1 = require("./tooltip/CrosshairContainer");
var ChartContext_1 = require("./ChartContext");
/**
 * @hidden
 */
var BaseChart = /** @class */ (function (_super) {
    __extends(BaseChart, _super);
    function BaseChart(props) {
        var _this = _super.call(this, props) || this;
        /**
         * @hidden
         */
        _this.chartInstance = null;
        _this._element = null;
        _this.optionsStore = {};
        _this.optionsUnsubscriber = Function.prototype;
        _this.themeStore = {};
        _this.themeUnsubscriber = Function.prototype;
        _this.observersStore = {};
        /* Chart handlers */
        /**
         * @hidden
         */
        _this.onRender = function (e) {
            if (_this.chartInstance !== null) {
                _this.surface = e.sender.surface;
                _this.trigger('render', e);
            }
        };
        /**
         * @hidden
         */
        _this.onLegendItemClick = function (e) {
            if (_this.chartInstance !== null) {
                /**
                 * In "controlled" state the user should toggle the series data visibility
                 */
                if (_this.props.onLegendItemClick) {
                    _this.trigger('legendItemClick', e);
                }
                else {
                    var series = _this.optionsStore.getState().series;
                    if (!series) {
                        return;
                    }
                    var payload = {};
                    var seriesIndex = e.seriesIndex, pointIndex = e.pointIndex;
                    var seriesByIndex = series[seriesIndex];
                    if (pointIndex === undefined) {
                        payload = Object.assign({}, seriesByIndex, { visible: main_2.toggle(seriesByIndex.visible) });
                    }
                    else {
                        var pv = seriesByIndex.pointVisibility = seriesByIndex.pointVisibility || [];
                        pv[pointIndex] = main_2.toggle(pv[pointIndex]);
                        payload = Object.assign({}, seriesByIndex);
                    }
                    _this.optionsStore.dispatch({
                        chartCollectionIdxKey: "series_" + seriesIndex,
                        payload: payload
                    });
                }
            }
        };
        /* Dom event handlers */
        /**
         * @hidden
         */
        _this.onWindowResize = function () {
            if (_this.chartInstance !== null) {
                _this.chartInstance.resize();
            }
        };
        /**
         * @hidden
         */
        _this.onChartMouseLeave = function (e) {
            var domEvent = dom_event_1.toDomEvent(_this, e);
            var isDefaultPrevented = _this.triggerDomEvent('onMouseLeave', domEvent);
            if (isDefaultPrevented) {
                e.preventDefault();
            }
            else if (_this.chartInstance !== null) {
                _this.chartInstance.hideElements();
            }
        };
        /**
         * @hidden
         */
        _this.onChildMouseLeave = function (e) {
            var syntheticEvent = e.syntheticEvent;
            if (_this.chartInstance && !main_1.hasParent(syntheticEvent.relatedTarget, _this.element)) {
                _this.chartInstance.hideElements();
            }
            return false;
        };
        _this.optionsStore = store_1.default(reducer_1.optionsReducer);
        _this.observersStore = store_1.default(reducer_1.observersReducer);
        _this.childrenObserver = new kendo_charts_1.InstanceObserver(_this, { onMouseLeave: 'onChildMouseLeave' });
        _this.contextValue = {
            optionsStore: _this.optionsStore,
            observersStore: _this.observersStore,
            childrenObserver: _this.childrenObserver
        };
        _this.themeStore = store_1.default(reducer_1.themeReducer);
        _this.chartObserver = new kendo_charts_1.InstanceObserver(_this, { render: 'onRender', legendItemClick: 'onLegendItemClick' });
        return _this;
    }
    Object.defineProperty(BaseChart.prototype, "element", {
        /**
         * @hidden
         */
        get: function () {
            return this._element;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    BaseChart.prototype.componentDidMount = function () {
        theme_service_1.loadTheme(this.themeStore, this.instantiateCoreChart.bind(this));
        this.optionsUnsubscriber = this.optionsStore.subscribe(this.refresh.bind(this));
        this.themeUnsubscriber = this.themeStore.subscribe(this.refresh.bind(this));
        window.addEventListener('resize', this.onWindowResize);
    };
    /**
     * @hidden
     */
    BaseChart.prototype.componentWillUnmount = function () {
        this.optionsUnsubscriber();
        this.themeUnsubscriber();
        if (this.chartInstance !== null) {
            this.chartInstance.destroy();
            this.chartInstance = null;
        }
        window.removeEventListener('resize', this.onWindowResize);
    };
    /**
     * @hidden
     */
    BaseChart.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, dir = _a.dir, children = _a.children, spreadProps = __rest(_a, ["dir", "children"]);
        if (this.chartInstance !== null) {
            var currentIntlService = kendo_react_intl_1.provideIntlService(this);
            var chartService = this.chartInstance.chartService;
            var localeChanged = currentIntlService.locale !== chartService._intlService.locale;
            var shouldUpdate = Object.entries(prevProps)
                .filter(function (keyValue) { return (keyValue[0] !== 'dir' && keyValue[0] !== 'children'); })
                .some(function (keyValue) {
                var key = keyValue[0], value = keyValue[1];
                return !(spreadProps.hasOwnProperty(key) && spreadProps[key] === value);
            });
            if (localeChanged) {
                this.chartInstance.chartService._intlService = currentIntlService;
                this.chartInstance.chartService.format._intlService = currentIntlService;
                if (!shouldUpdate) {
                    this.chartInstance.noTransitionsRedraw();
                }
            }
            if (shouldUpdate) {
                this.refresh();
            }
            if (prevProps.dir !== dir) {
                this.chartInstance.setDirection(this.getDirection(dir));
            }
        }
    };
    /**
     * @hidden
     */
    BaseChart.prototype.render = function () {
        var _this = this;
        var _a = this.props, _b = _a.style, style = _b === void 0 ? {} : _b, wrapperClassName = _a.wrapperClassName, wrapper = _a.wrapper, children = _a.children;
        var chartStyles = Object.assign({}, style, { position: 'relative' });
        var content = React.createElement(wrapper, {
            className: wrapperClassName,
            style: chartStyles,
            key: 'chartElement'
        }, (React.createElement("div", { onMouseLeave: this.onChartMouseLeave, ref: function (el) { return _this._element = el; }, className: "k-chart-surface" }, children)));
        return (React.createElement(ChartContext_1.ChartContext.Provider, { value: this.contextValue },
            React.createElement(Series_1.SeriesTooltip, { key: "seriesTooltip" }),
            React.createElement(CrosshairContainer_1.CrosshairTooltipContainer, { key: "crosshairTooltips" }),
            content));
    };
    /**
     * @hidden
     */
    BaseChart.prototype.getDirection = function (dir) {
        var _this = this;
        var directionFromWindow = function () { return kendo_react_common_1.canUseDOM && window.getComputedStyle(_this.element).direction; };
        var direction = dir !== undefined ? dir : (directionFromWindow() || 'ltr');
        return direction === 'rtl';
    };
    /**
     * @hidden
     */
    BaseChart.prototype.getChartOptions = function () {
        var _a = this.props, renderAs = _a.renderAs, pannable = _a.pannable, zoomable = _a.zoomable, transitions = _a.transitions, seriesColors = _a.seriesColors, seriesDefaults = _a.seriesDefaults, axisDefaults = _a.axisDefaults, deriveOptionsFromParent = _a.deriveOptionsFromParent;
        var chartOptions = {};
        // undefined clears chart defaults which leads to several issues
        if (renderAs !== undefined) {
            chartOptions.renderAs = renderAs;
        }
        if (pannable !== undefined) {
            chartOptions.pannable = pannable;
        }
        if (zoomable !== undefined) {
            chartOptions.zoomable = zoomable;
        }
        if (transitions !== undefined) {
            chartOptions.transitions = transitions;
        }
        if (seriesColors !== undefined) {
            chartOptions.seriesColors = seriesColors;
        }
        if (seriesDefaults !== undefined) {
            chartOptions.seriesDefaults = seriesDefaults;
        }
        if (axisDefaults !== undefined) {
            chartOptions.axisDefaults = axisDefaults;
        }
        chartOptions = Object.assign(chartOptions, this.optionsStore.getState());
        if (deriveOptionsFromParent) {
            chartOptions = deriveOptionsFromParent(chartOptions);
        }
        return chartOptions;
    };
    /**
     * @hidden
     */
    BaseChart.prototype.refresh = function () {
        if (this.chartInstance !== null) {
            var themeOptions = this.themeStore.getState();
            var chartOptions = this.getChartOptions();
            if (this.props.onRefresh) {
                this.props.onRefresh.call(undefined, chartOptions, themeOptions, this.chartInstance);
            }
            else {
                this.chartInstance.setOptions(chartOptions, themeOptions);
            }
        }
    };
    /**
     * @hidden
     */
    BaseChart.prototype.instantiateCoreChart = function () {
        var _a = this.props, dir = _a.dir, chartConstructor = _a.chartConstructor;
        var chartOptions = this.getChartOptions();
        this.chartInstance = new chartConstructor(this.element, chartOptions, this.themeStore.getState(), {
            rtl: this.getDirection(dir),
            intlService: kendo_react_intl_1.provideIntlService(this),
            observer: this.chartObserver,
            sender: this
        });
    };
    /* Triggers public dom event handlers */
    /**
     * @hidden
     */
    BaseChart.prototype.trigger = function (name, e) {
        var target = this.props.getTarget();
        var eventObject = chart_event_builder_1.create(name, e, target);
        var handler = 'on' + name.charAt(0).toUpperCase() + name.slice(1);
        var observers = this.observersStore.getState();
        var isDefaultPrevented = false;
        for (var idx = 0; idx < observers.length; idx++) {
            if (observers[idx].trigger(name, e)) {
                isDefaultPrevented = true;
            }
        }
        /* We have not prevented the event internally, now pass it to the user */
        if (isDefaultPrevented === false
            && eventObject
            && this.props.hasOwnProperty(handler)) {
            this.props[handler].call(undefined, eventObject);
            return eventObject.isDefaultPrevented && eventObject.isDefaultPrevented();
        }
        return isDefaultPrevented;
    };
    /* Used by (event)InstanceObserver to check the wrapper for supported events */
    /**
     * @hidden
     */
    BaseChart.prototype.requiresHandlers = function (names) {
        for (var idx = 0; idx < names.length; idx++) {
            var name_1 = names[idx];
            var handler = 'on' + name_1.charAt(0).toUpperCase() + name_1.slice(1);
            if (this.props.hasOwnProperty(handler)) {
                return true;
            }
        }
        return false;
    };
    /* Triggers private dom event handlers */
    /**
     * @hidden
     */
    BaseChart.prototype.triggerDomEvent = function (name, e) {
        var observers = this.observersStore.getState();
        var isDefaultPrevented = false;
        for (var idx = 0; idx < observers.length; idx++) {
            if (observers[idx].trigger(name, e)) {
                isDefaultPrevented = true;
            }
        }
        return isDefaultPrevented;
    };
    /**
     * @hidden
     */
    BaseChart.propTypes = {
        dir: PropTypes.string,
        renderAs: PropTypes.oneOf(['svg', 'canvas'])
    };
    /**
     * @hidden
     */
    BaseChart.defaultProps = {
        renderAs: 'svg'
    };
    return BaseChart;
}(React.Component));
exports.BaseChart = BaseChart;
kendo_react_intl_1.registerForIntl(BaseChart);
kendo_charts_1.DomEventsBuilder.register(dom_events_builder_1.DomEventsBuilder);
//# sourceMappingURL=BaseChart.js.map