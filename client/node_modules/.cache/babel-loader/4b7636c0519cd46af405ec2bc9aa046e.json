{"ast":null,"code":"/*!\r\n * mime-types\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n'use strict';\n/**\r\n * Module dependencies.\r\n * @private\r\n */\n\nvar db = require('mime-db');\n\nvar extname = require('path').extname;\n/**\r\n * Module variables.\r\n * @private\r\n */\n\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/;\nvar TEXT_TYPE_REGEXP = /^text\\//i;\n/**\r\n * Module exports.\r\n * @public\r\n */\n\nexports.charset = charset;\nexports.charsets = {\n  lookup: charset\n};\nexports.contentType = contentType;\nexports.extension = extension;\nexports.extensions = Object.create(null);\nexports.lookup = lookup;\nexports.types = Object.create(null); // Populate the extensions/types maps\n\npopulateMaps(exports.extensions, exports.types);\n/**\r\n * Get the default charset for a MIME type.\r\n *\r\n * @param {string} type\r\n * @return {boolean|string}\r\n */\n\nfunction charset(type) {\n  if (!type || typeof type !== 'string') {\n    return false;\n  } // TODO: use media-typer\n\n\n  var match = EXTRACT_TYPE_REGEXP.exec(type);\n  var mime = match && db[match[1].toLowerCase()];\n\n  if (mime && mime.charset) {\n    return mime.charset;\n  } // default text/* to utf-8\n\n\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8';\n  }\n\n  return false;\n}\n/**\r\n * Create a full Content-Type header given a MIME type or extension.\r\n *\r\n * @param {string} str\r\n * @return {boolean|string}\r\n */\n\n\nfunction contentType(str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false;\n  }\n\n  var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;\n\n  if (!mime) {\n    return false;\n  } // TODO: use content-type or other module\n\n\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime);\n    if (charset) mime += '; charset=' + charset.toLowerCase();\n  }\n\n  return mime;\n}\n/**\r\n * Get the default extension for a MIME type.\r\n *\r\n * @param {string} type\r\n * @return {boolean|string}\r\n */\n\n\nfunction extension(type) {\n  if (!type || typeof type !== 'string') {\n    return false;\n  } // TODO: use media-typer\n\n\n  var match = EXTRACT_TYPE_REGEXP.exec(type); // get extensions\n\n  var exts = match && exports.extensions[match[1].toLowerCase()];\n\n  if (!exts || !exts.length) {\n    return false;\n  }\n\n  return exts[0];\n}\n/**\r\n * Lookup the MIME type for a file path/extension.\r\n *\r\n * @param {string} path\r\n * @return {boolean|string}\r\n */\n\n\nfunction lookup(path) {\n  if (!path || typeof path !== 'string') {\n    return false;\n  } // get the extension (\"ext\" or \".ext\" or full path)\n\n\n  var extension = extname('x.' + path).toLowerCase().substr(1);\n\n  if (!extension) {\n    return false;\n  }\n\n  return exports.types[extension] || false;\n}\n/**\r\n * Populate the extensions and types maps.\r\n * @private\r\n */\n\n\nfunction populateMaps(extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana'];\n  Object.keys(db).forEach(function forEachMimeType(type) {\n    var mime = db[type];\n    var exts = mime.extensions;\n\n    if (!exts || !exts.length) {\n      return;\n    } // mime -> extensions\n\n\n    extensions[type] = exts; // extension -> mime\n\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i];\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source);\n        var to = preference.indexOf(mime.source);\n\n        if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {\n          // skip the remapping\n          continue;\n        }\n      } // set the extension -> mime\n\n\n      types[extension] = type;\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/nithya/Desktop/team-4/client/node_modules/mime-types/index.js"],"names":["db","require","extname","EXTRACT_TYPE_REGEXP","TEXT_TYPE_REGEXP","exports","charset","charsets","lookup","contentType","extension","extensions","Object","create","types","populateMaps","type","match","exec","mime","toLowerCase","test","str","indexOf","exts","length","path","substr","preference","undefined","keys","forEach","forEachMimeType","i","from","source","to"],"mappings":"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","sourcesContent":["/*!\r\n * mime-types\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar db = require('mime-db')\r\nvar extname = require('path').extname\r\n\r\n/**\r\n * Module variables.\r\n * @private\r\n */\r\n\r\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\r\nvar TEXT_TYPE_REGEXP = /^text\\//i\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nexports.charset = charset\r\nexports.charsets = { lookup: charset }\r\nexports.contentType = contentType\r\nexports.extension = extension\r\nexports.extensions = Object.create(null)\r\nexports.lookup = lookup\r\nexports.types = Object.create(null)\r\n\r\n// Populate the extensions/types maps\r\npopulateMaps(exports.extensions, exports.types)\r\n\r\n/**\r\n * Get the default charset for a MIME type.\r\n *\r\n * @param {string} type\r\n * @return {boolean|string}\r\n */\r\n\r\nfunction charset (type) {\r\n  if (!type || typeof type !== 'string') {\r\n    return false\r\n  }\r\n\r\n  // TODO: use media-typer\r\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\r\n  var mime = match && db[match[1].toLowerCase()]\r\n\r\n  if (mime && mime.charset) {\r\n    return mime.charset\r\n  }\r\n\r\n  // default text/* to utf-8\r\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\r\n    return 'UTF-8'\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n/**\r\n * Create a full Content-Type header given a MIME type or extension.\r\n *\r\n * @param {string} str\r\n * @return {boolean|string}\r\n */\r\n\r\nfunction contentType (str) {\r\n  // TODO: should this even be in this module?\r\n  if (!str || typeof str !== 'string') {\r\n    return false\r\n  }\r\n\r\n  var mime = str.indexOf('/') === -1\r\n    ? exports.lookup(str)\r\n    : str\r\n\r\n  if (!mime) {\r\n    return false\r\n  }\r\n\r\n  // TODO: use content-type or other module\r\n  if (mime.indexOf('charset') === -1) {\r\n    var charset = exports.charset(mime)\r\n    if (charset) mime += '; charset=' + charset.toLowerCase()\r\n  }\r\n\r\n  return mime\r\n}\r\n\r\n/**\r\n * Get the default extension for a MIME type.\r\n *\r\n * @param {string} type\r\n * @return {boolean|string}\r\n */\r\n\r\nfunction extension (type) {\r\n  if (!type || typeof type !== 'string') {\r\n    return false\r\n  }\r\n\r\n  // TODO: use media-typer\r\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\r\n\r\n  // get extensions\r\n  var exts = match && exports.extensions[match[1].toLowerCase()]\r\n\r\n  if (!exts || !exts.length) {\r\n    return false\r\n  }\r\n\r\n  return exts[0]\r\n}\r\n\r\n/**\r\n * Lookup the MIME type for a file path/extension.\r\n *\r\n * @param {string} path\r\n * @return {boolean|string}\r\n */\r\n\r\nfunction lookup (path) {\r\n  if (!path || typeof path !== 'string') {\r\n    return false\r\n  }\r\n\r\n  // get the extension (\"ext\" or \".ext\" or full path)\r\n  var extension = extname('x.' + path)\r\n    .toLowerCase()\r\n    .substr(1)\r\n\r\n  if (!extension) {\r\n    return false\r\n  }\r\n\r\n  return exports.types[extension] || false\r\n}\r\n\r\n/**\r\n * Populate the extensions and types maps.\r\n * @private\r\n */\r\n\r\nfunction populateMaps (extensions, types) {\r\n  // source preference (least -> most)\r\n  var preference = ['nginx', 'apache', undefined, 'iana']\r\n\r\n  Object.keys(db).forEach(function forEachMimeType (type) {\r\n    var mime = db[type]\r\n    var exts = mime.extensions\r\n\r\n    if (!exts || !exts.length) {\r\n      return\r\n    }\r\n\r\n    // mime -> extensions\r\n    extensions[type] = exts\r\n\r\n    // extension -> mime\r\n    for (var i = 0; i < exts.length; i++) {\r\n      var extension = exts[i]\r\n\r\n      if (types[extension]) {\r\n        var from = preference.indexOf(db[types[extension]].source)\r\n        var to = preference.indexOf(mime.source)\r\n\r\n        if (types[extension] !== 'application/octet-stream' &&\r\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\r\n          // skip the remapping\r\n          continue\r\n        }\r\n      }\r\n\r\n      // set the extension -> mime\r\n      types[extension] = type\r\n    }\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"script"}