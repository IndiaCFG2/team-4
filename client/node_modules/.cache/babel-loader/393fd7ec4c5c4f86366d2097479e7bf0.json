{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // Export Node.js internal encodings.\n\n\nmodule.exports = {\n  // Encodings\n  utf8: {\n    type: \"_internal\",\n    bomAware: true\n  },\n  cesu8: {\n    type: \"_internal\",\n    bomAware: true\n  },\n  unicode11utf8: \"utf8\",\n  ucs2: {\n    type: \"_internal\",\n    bomAware: true\n  },\n  utf16le: \"ucs2\",\n  binary: {\n    type: \"_internal\"\n  },\n  base64: {\n    type: \"_internal\"\n  },\n  hex: {\n    type: \"_internal\"\n  },\n  // Codec.\n  _internal: InternalCodec\n}; //------------------------------------------------------------------------------\n\nfunction InternalCodec(codecOptions, iconv) {\n  this.enc = codecOptions.encodingName;\n  this.bomAware = codecOptions.bomAware;\n  if (this.enc === \"base64\") this.encoder = InternalEncoderBase64;else if (this.enc === \"cesu8\") {\n    this.enc = \"utf8\"; // Use utf8 for decoding.\n\n    this.encoder = InternalEncoderCesu8; // Add decoder for versions of Node not supporting CESU-8\n\n    if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== 'ðŸ’©') {\n      this.decoder = InternalDecoderCesu8;\n      this.defaultCharUnicode = iconv.defaultCharUnicode;\n    }\n  }\n}\n\nInternalCodec.prototype.encoder = InternalEncoder;\nInternalCodec.prototype.decoder = InternalDecoder; //------------------------------------------------------------------------------\n// We use node.js internal decoder. Its signature is the same as ours.\n\nvar StringDecoder = require('string_decoder').StringDecoder;\n\nif (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.\n  StringDecoder.prototype.end = function () {};\n\nfunction InternalDecoder(options, codec) {\n  StringDecoder.call(this, codec.enc);\n}\n\nInternalDecoder.prototype = StringDecoder.prototype; //------------------------------------------------------------------------------\n// Encoder is mostly trivial\n\nfunction InternalEncoder(options, codec) {\n  this.enc = codec.enc;\n}\n\nInternalEncoder.prototype.write = function (str) {\n  return Buffer.from(str, this.enc);\n};\n\nInternalEncoder.prototype.end = function () {}; //------------------------------------------------------------------------------\n// Except base64 encoder, which must keep its state.\n\n\nfunction InternalEncoderBase64(options, codec) {\n  this.prevStr = '';\n}\n\nInternalEncoderBase64.prototype.write = function (str) {\n  str = this.prevStr + str;\n  var completeQuads = str.length - str.length % 4;\n  this.prevStr = str.slice(completeQuads);\n  str = str.slice(0, completeQuads);\n  return Buffer.from(str, \"base64\");\n};\n\nInternalEncoderBase64.prototype.end = function () {\n  return Buffer.from(this.prevStr, \"base64\");\n}; //------------------------------------------------------------------------------\n// CESU-8 encoder is also special.\n\n\nfunction InternalEncoderCesu8(options, codec) {}\n\nInternalEncoderCesu8.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length * 3),\n      bufIdx = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var charCode = str.charCodeAt(i); // Naive implementation, but it works because CESU-8 is especially easy\n    // to convert from UTF-16 (which all JS strings are encoded in).\n\n    if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {\n      buf[bufIdx++] = 0xC0 + (charCode >>> 6);\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n    } else {\n      // charCode will always be < 0x10000 in javascript.\n      buf[bufIdx++] = 0xE0 + (charCode >>> 12);\n      buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);\n      buf[bufIdx++] = 0x80 + (charCode & 0x3f);\n    }\n  }\n\n  return buf.slice(0, bufIdx);\n};\n\nInternalEncoderCesu8.prototype.end = function () {}; //------------------------------------------------------------------------------\n// CESU-8 decoder is not implemented in Node v4.0+\n\n\nfunction InternalDecoderCesu8(options, codec) {\n  this.acc = 0;\n  this.contBytes = 0;\n  this.accBytes = 0;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n}\n\nInternalDecoderCesu8.prototype.write = function (buf) {\n  var acc = this.acc,\n      contBytes = this.contBytes,\n      accBytes = this.accBytes,\n      res = '';\n\n  for (var i = 0; i < buf.length; i++) {\n    var curByte = buf[i];\n\n    if ((curByte & 0xC0) !== 0x80) {\n      // Leading byte\n      if (contBytes > 0) {\n        // Previous code is invalid\n        res += this.defaultCharUnicode;\n        contBytes = 0;\n      }\n\n      if (curByte < 0x80) {\n        // Single-byte code\n        res += String.fromCharCode(curByte);\n      } else if (curByte < 0xE0) {\n        // Two-byte code\n        acc = curByte & 0x1F;\n        contBytes = 1;\n        accBytes = 1;\n      } else if (curByte < 0xF0) {\n        // Three-byte code\n        acc = curByte & 0x0F;\n        contBytes = 2;\n        accBytes = 1;\n      } else {\n        // Four or more are not supported for CESU-8.\n        res += this.defaultCharUnicode;\n      }\n    } else {\n      // Continuation byte\n      if (contBytes > 0) {\n        // We're waiting for it.\n        acc = acc << 6 | curByte & 0x3f;\n        contBytes--;\n        accBytes++;\n\n        if (contBytes === 0) {\n          // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)\n          if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else // Actually add character.\n            res += String.fromCharCode(acc);\n        }\n      } else {\n        // Unexpected continuation byte\n        res += this.defaultCharUnicode;\n      }\n    }\n  }\n\n  this.acc = acc;\n  this.contBytes = contBytes;\n  this.accBytes = accBytes;\n  return res;\n};\n\nInternalDecoderCesu8.prototype.end = function () {\n  var res = 0;\n  if (this.contBytes > 0) res += this.defaultCharUnicode;\n  return res;\n};","map":{"version":3,"sources":["C:/Users/nithya/Desktop/team-4/client/node_modules/iconv-lite/encodings/internal.js"],"names":["Buffer","require","module","exports","utf8","type","bomAware","cesu8","unicode11utf8","ucs2","utf16le","binary","base64","hex","_internal","InternalCodec","codecOptions","iconv","enc","encodingName","encoder","InternalEncoderBase64","InternalEncoderCesu8","from","toString","decoder","InternalDecoderCesu8","defaultCharUnicode","prototype","InternalEncoder","InternalDecoder","StringDecoder","end","options","codec","call","write","str","prevStr","completeQuads","length","slice","buf","alloc","bufIdx","i","charCode","charCodeAt","acc","contBytes","accBytes","res","curByte","String","fromCharCode"],"mappings":"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","sourcesContent":["\"use strict\";\r\nvar Buffer = require(\"safer-buffer\").Buffer;\r\n\r\n// Export Node.js internal encodings.\r\n\r\nmodule.exports = {\r\n    // Encodings\r\n    utf8:   { type: \"_internal\", bomAware: true},\r\n    cesu8:  { type: \"_internal\", bomAware: true},\r\n    unicode11utf8: \"utf8\",\r\n\r\n    ucs2:   { type: \"_internal\", bomAware: true},\r\n    utf16le: \"ucs2\",\r\n\r\n    binary: { type: \"_internal\" },\r\n    base64: { type: \"_internal\" },\r\n    hex:    { type: \"_internal\" },\r\n\r\n    // Codec.\r\n    _internal: InternalCodec,\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nfunction InternalCodec(codecOptions, iconv) {\r\n    this.enc = codecOptions.encodingName;\r\n    this.bomAware = codecOptions.bomAware;\r\n\r\n    if (this.enc === \"base64\")\r\n        this.encoder = InternalEncoderBase64;\r\n    else if (this.enc === \"cesu8\") {\r\n        this.enc = \"utf8\"; // Use utf8 for decoding.\r\n        this.encoder = InternalEncoderCesu8;\r\n\r\n        // Add decoder for versions of Node not supporting CESU-8\r\n        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== 'ðŸ’©') {\r\n            this.decoder = InternalDecoderCesu8;\r\n            this.defaultCharUnicode = iconv.defaultCharUnicode;\r\n        }\r\n    }\r\n}\r\n\r\nInternalCodec.prototype.encoder = InternalEncoder;\r\nInternalCodec.prototype.decoder = InternalDecoder;\r\n\r\n//------------------------------------------------------------------------------\r\n\r\n// We use node.js internal decoder. Its signature is the same as ours.\r\nvar StringDecoder = require('string_decoder').StringDecoder;\r\n\r\nif (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.\r\n    StringDecoder.prototype.end = function() {};\r\n\r\n\r\nfunction InternalDecoder(options, codec) {\r\n    StringDecoder.call(this, codec.enc);\r\n}\r\n\r\nInternalDecoder.prototype = StringDecoder.prototype;\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Encoder is mostly trivial\r\n\r\nfunction InternalEncoder(options, codec) {\r\n    this.enc = codec.enc;\r\n}\r\n\r\nInternalEncoder.prototype.write = function(str) {\r\n    return Buffer.from(str, this.enc);\r\n}\r\n\r\nInternalEncoder.prototype.end = function() {\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Except base64 encoder, which must keep its state.\r\n\r\nfunction InternalEncoderBase64(options, codec) {\r\n    this.prevStr = '';\r\n}\r\n\r\nInternalEncoderBase64.prototype.write = function(str) {\r\n    str = this.prevStr + str;\r\n    var completeQuads = str.length - (str.length % 4);\r\n    this.prevStr = str.slice(completeQuads);\r\n    str = str.slice(0, completeQuads);\r\n\r\n    return Buffer.from(str, \"base64\");\r\n}\r\n\r\nInternalEncoderBase64.prototype.end = function() {\r\n    return Buffer.from(this.prevStr, \"base64\");\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// CESU-8 encoder is also special.\r\n\r\nfunction InternalEncoderCesu8(options, codec) {\r\n}\r\n\r\nInternalEncoderCesu8.prototype.write = function(str) {\r\n    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;\r\n    for (var i = 0; i < str.length; i++) {\r\n        var charCode = str.charCodeAt(i);\r\n        // Naive implementation, but it works because CESU-8 is especially easy\r\n        // to convert from UTF-16 (which all JS strings are encoded in).\r\n        if (charCode < 0x80)\r\n            buf[bufIdx++] = charCode;\r\n        else if (charCode < 0x800) {\r\n            buf[bufIdx++] = 0xC0 + (charCode >>> 6);\r\n            buf[bufIdx++] = 0x80 + (charCode & 0x3f);\r\n        }\r\n        else { // charCode will always be < 0x10000 in javascript.\r\n            buf[bufIdx++] = 0xE0 + (charCode >>> 12);\r\n            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);\r\n            buf[bufIdx++] = 0x80 + (charCode & 0x3f);\r\n        }\r\n    }\r\n    return buf.slice(0, bufIdx);\r\n}\r\n\r\nInternalEncoderCesu8.prototype.end = function() {\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// CESU-8 decoder is not implemented in Node v4.0+\r\n\r\nfunction InternalDecoderCesu8(options, codec) {\r\n    this.acc = 0;\r\n    this.contBytes = 0;\r\n    this.accBytes = 0;\r\n    this.defaultCharUnicode = codec.defaultCharUnicode;\r\n}\r\n\r\nInternalDecoderCesu8.prototype.write = function(buf) {\r\n    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, \r\n        res = '';\r\n    for (var i = 0; i < buf.length; i++) {\r\n        var curByte = buf[i];\r\n        if ((curByte & 0xC0) !== 0x80) { // Leading byte\r\n            if (contBytes > 0) { // Previous code is invalid\r\n                res += this.defaultCharUnicode;\r\n                contBytes = 0;\r\n            }\r\n\r\n            if (curByte < 0x80) { // Single-byte code\r\n                res += String.fromCharCode(curByte);\r\n            } else if (curByte < 0xE0) { // Two-byte code\r\n                acc = curByte & 0x1F;\r\n                contBytes = 1; accBytes = 1;\r\n            } else if (curByte < 0xF0) { // Three-byte code\r\n                acc = curByte & 0x0F;\r\n                contBytes = 2; accBytes = 1;\r\n            } else { // Four or more are not supported for CESU-8.\r\n                res += this.defaultCharUnicode;\r\n            }\r\n        } else { // Continuation byte\r\n            if (contBytes > 0) { // We're waiting for it.\r\n                acc = (acc << 6) | (curByte & 0x3f);\r\n                contBytes--; accBytes++;\r\n                if (contBytes === 0) {\r\n                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)\r\n                    if (accBytes === 2 && acc < 0x80 && acc > 0)\r\n                        res += this.defaultCharUnicode;\r\n                    else if (accBytes === 3 && acc < 0x800)\r\n                        res += this.defaultCharUnicode;\r\n                    else\r\n                        // Actually add character.\r\n                        res += String.fromCharCode(acc);\r\n                }\r\n            } else { // Unexpected continuation byte\r\n                res += this.defaultCharUnicode;\r\n            }\r\n        }\r\n    }\r\n    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;\r\n    return res;\r\n}\r\n\r\nInternalDecoderCesu8.prototype.end = function() {\r\n    var res = 0;\r\n    if (this.contBytes > 0)\r\n        res += this.defaultCharUnicode;\r\n    return res;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}