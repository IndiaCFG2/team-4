{"ast":null,"code":"/*!\r\n * body-parser\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n'use strict';\n/**\r\n * Module dependencies.\r\n * @private\r\n */\n\nvar bytes = require('bytes');\n\nvar contentType = require('content-type');\n\nvar createError = require('http-errors');\n\nvar debug = require('debug')('body-parser:json');\n\nvar read = require('../read');\n\nvar typeis = require('type-is');\n/**\r\n * Module exports.\r\n */\n\n\nmodule.exports = json;\n/**\r\n * RegExp to match the first non-space in a string.\r\n *\r\n * Allowed whitespace is defined in RFC 7159:\r\n *\r\n *    ws = *(\r\n *            %x20 /              ; Space\r\n *            %x09 /              ; Horizontal tab\r\n *            %x0A /              ; Line feed or New line\r\n *            %x0D )              ; Carriage return\r\n */\n\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*(.)/; // eslint-disable-line no-control-regex\n\n/**\r\n * Create a middleware to parse JSON bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\n\nfunction json(options) {\n  var opts = options || {};\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var inflate = opts.inflate !== false;\n  var reviver = opts.reviver;\n  var strict = opts.strict !== false;\n  var type = opts.type || 'application/json';\n  var verify = opts.verify || false;\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  } // create the appropriate type checking function\n\n\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n\n  function parse(body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {};\n    }\n\n    if (strict) {\n      var first = firstchar(body);\n\n      if (first !== '{' && first !== '[') {\n        debug('strict violation');\n        throw createStrictSyntaxError(body, first);\n      }\n    }\n\n    try {\n      debug('parse json');\n      return JSON.parse(body, reviver);\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      });\n    }\n  }\n\n  return function jsonParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n\n    req.body = req.body || {}; // skip requests without bodies\n\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n\n    debug('content-type %j', req.headers['content-type']); // determine if request should be parsed\n\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    } // assert charset per RFC 7159 sec 8.1\n\n\n    var charset = getCharset(req) || 'utf-8';\n\n    if (charset.substr(0, 4) !== 'utf-') {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    } // read\n\n\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n/**\r\n * Create strict violation syntax error matching native error.\r\n *\r\n * @param {string} str\r\n * @param {string} char\r\n * @return {Error}\r\n * @private\r\n */\n\n\nfunction createStrictSyntaxError(str, char) {\n  var index = str.indexOf(char);\n  var partial = str.substring(0, index) + '#';\n\n  try {\n    JSON.parse(partial);\n    /* istanbul ignore next */\n\n    throw new SyntaxError('strict violation');\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace('#', char),\n      stack: e.stack\n    });\n  }\n}\n/**\r\n * Get the first non-whitespace character in a string.\r\n *\r\n * @param {string} str\r\n * @return {function}\r\n * @private\r\n */\n\n\nfunction firstchar(str) {\n  return FIRST_CHAR_REGEXP.exec(str)[1];\n}\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\n\n\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\r\n * Normalize a SyntaxError for JSON.parse.\r\n *\r\n * @param {SyntaxError} error\r\n * @param {object} obj\r\n * @return {SyntaxError}\r\n */\n\n\nfunction normalizeJsonSyntaxError(error, obj) {\n  var keys = Object.getOwnPropertyNames(error);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key];\n    }\n  } // replace stack before message for Node.js 0.10 and below\n\n\n  error.stack = obj.stack.replace(error.message, obj.message);\n  error.message = obj.message;\n  return error;\n}\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\n\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"sources":["C:/Users/nithya/Desktop/team-4/client/node_modules/body-parser/lib/types/json.js"],"names":["bytes","require","contentType","createError","debug","read","typeis","module","exports","json","FIRST_CHAR_REGEXP","options","opts","limit","parse","inflate","reviver","strict","type","verify","TypeError","shouldParse","typeChecker","body","length","first","firstchar","createStrictSyntaxError","JSON","e","normalizeJsonSyntaxError","message","stack","jsonParser","req","res","next","_body","hasBody","headers","charset","getCharset","substr","toUpperCase","encoding","str","char","index","indexOf","partial","substring","SyntaxError","replace","exec","parameters","toLowerCase","undefined","error","obj","keys","Object","getOwnPropertyNames","i","key","checkType","Boolean"],"mappings":"AAAA;;;;;;AAOA;AAEA;;;;;AAKA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,cAAD,CAAzB;;AACA,IAAIE,WAAW,GAAGF,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAIG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAAP,CAAiB,kBAAjB,CAAZ;;AACA,IAAII,IAAI,GAAGJ,OAAO,CAAC,SAAD,CAAlB;;AACA,IAAIK,MAAM,GAAGL,OAAO,CAAC,SAAD,CAApB;AAEA;;;;;AAIAM,MAAM,CAACC,OAAP,GAAiBC,IAAjB;AAEA;;;;;;;;;;;;AAYA,IAAIC,iBAAiB,GAAG,yBAAxB,C,CAAkD;;AAElD;;;;;;;;AAQA,SAASD,IAAT,CAAeE,OAAf,EAAwB;AACtB,MAAIC,IAAI,GAAGD,OAAO,IAAI,EAAtB;AAEA,MAAIE,KAAK,GAAG,OAAOD,IAAI,CAACC,KAAZ,KAAsB,QAAtB,GACRb,KAAK,CAACc,KAAN,CAAYF,IAAI,CAACC,KAAL,IAAc,OAA1B,CADQ,GAERD,IAAI,CAACC,KAFT;AAGA,MAAIE,OAAO,GAAGH,IAAI,CAACG,OAAL,KAAiB,KAA/B;AACA,MAAIC,OAAO,GAAGJ,IAAI,CAACI,OAAnB;AACA,MAAIC,MAAM,GAAGL,IAAI,CAACK,MAAL,KAAgB,KAA7B;AACA,MAAIC,IAAI,GAAGN,IAAI,CAACM,IAAL,IAAa,kBAAxB;AACA,MAAIC,MAAM,GAAGP,IAAI,CAACO,MAAL,IAAe,KAA5B;;AAEA,MAAIA,MAAM,KAAK,KAAX,IAAoB,OAAOA,MAAP,KAAkB,UAA1C,EAAsD;AACpD,UAAM,IAAIC,SAAJ,CAAc,gCAAd,CAAN;AACD,GAdqB,CAgBtB;;;AACA,MAAIC,WAAW,GAAG,OAAOH,IAAP,KAAgB,UAAhB,GACdI,WAAW,CAACJ,IAAD,CADG,GAEdA,IAFJ;;AAIA,WAASJ,KAAT,CAAgBS,IAAhB,EAAsB;AACpB,QAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;AACrB;AACA;AACA,aAAO,EAAP;AACD;;AAED,QAAIP,MAAJ,EAAY;AACV,UAAIQ,KAAK,GAAGC,SAAS,CAACH,IAAD,CAArB;;AAEA,UAAIE,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,GAA/B,EAAoC;AAClCrB,QAAAA,KAAK,CAAC,kBAAD,CAAL;AACA,cAAMuB,uBAAuB,CAACJ,IAAD,EAAOE,KAAP,CAA7B;AACD;AACF;;AAED,QAAI;AACFrB,MAAAA,KAAK,CAAC,YAAD,CAAL;AACA,aAAOwB,IAAI,CAACd,KAAL,CAAWS,IAAX,EAAiBP,OAAjB,CAAP;AACD,KAHD,CAGE,OAAOa,CAAP,EAAU;AACV,YAAMC,wBAAwB,CAACD,CAAD,EAAI;AAChCE,QAAAA,OAAO,EAAEF,CAAC,CAACE,OADqB;AAEhCC,QAAAA,KAAK,EAAEH,CAAC,CAACG;AAFuB,OAAJ,CAA9B;AAID;AACF;;AAED,SAAO,SAASC,UAAT,CAAqBC,GAArB,EAA0BC,GAA1B,EAA+BC,IAA/B,EAAqC;AAC1C,QAAIF,GAAG,CAACG,KAAR,EAAe;AACbjC,MAAAA,KAAK,CAAC,qBAAD,CAAL;AACAgC,MAAAA,IAAI;AACJ;AACD;;AAEDF,IAAAA,GAAG,CAACX,IAAJ,GAAWW,GAAG,CAACX,IAAJ,IAAY,EAAvB,CAP0C,CAS1C;;AACA,QAAI,CAACjB,MAAM,CAACgC,OAAP,CAAeJ,GAAf,CAAL,EAA0B;AACxB9B,MAAAA,KAAK,CAAC,iBAAD,CAAL;AACAgC,MAAAA,IAAI;AACJ;AACD;;AAEDhC,IAAAA,KAAK,CAAC,iBAAD,EAAoB8B,GAAG,CAACK,OAAJ,CAAY,cAAZ,CAApB,CAAL,CAhB0C,CAkB1C;;AACA,QAAI,CAAClB,WAAW,CAACa,GAAD,CAAhB,EAAuB;AACrB9B,MAAAA,KAAK,CAAC,cAAD,CAAL;AACAgC,MAAAA,IAAI;AACJ;AACD,KAvByC,CAyB1C;;;AACA,QAAII,OAAO,GAAGC,UAAU,CAACP,GAAD,CAAV,IAAmB,OAAjC;;AACA,QAAIM,OAAO,CAACE,MAAR,CAAe,CAAf,EAAkB,CAAlB,MAAyB,MAA7B,EAAqC;AACnCtC,MAAAA,KAAK,CAAC,iBAAD,CAAL;AACAgC,MAAAA,IAAI,CAACjC,WAAW,CAAC,GAAD,EAAM,0BAA0BqC,OAAO,CAACG,WAAR,EAA1B,GAAkD,GAAxD,EAA6D;AAC3EH,QAAAA,OAAO,EAAEA,OADkE;AAE3EtB,QAAAA,IAAI,EAAE;AAFqE,OAA7D,CAAZ,CAAJ;AAIA;AACD,KAlCyC,CAoC1C;;;AACAb,IAAAA,IAAI,CAAC6B,GAAD,EAAMC,GAAN,EAAWC,IAAX,EAAiBtB,KAAjB,EAAwBV,KAAxB,EAA+B;AACjCwC,MAAAA,QAAQ,EAAEJ,OADuB;AAEjCzB,MAAAA,OAAO,EAAEA,OAFwB;AAGjCF,MAAAA,KAAK,EAAEA,KAH0B;AAIjCM,MAAAA,MAAM,EAAEA;AAJyB,KAA/B,CAAJ;AAMD,GA3CD;AA4CD;AAED;;;;;;;;;;AASA,SAASQ,uBAAT,CAAkCkB,GAAlC,EAAuCC,IAAvC,EAA6C;AAC3C,MAAIC,KAAK,GAAGF,GAAG,CAACG,OAAJ,CAAYF,IAAZ,CAAZ;AACA,MAAIG,OAAO,GAAGJ,GAAG,CAACK,SAAJ,CAAc,CAAd,EAAiBH,KAAjB,IAA0B,GAAxC;;AAEA,MAAI;AACFnB,IAAAA,IAAI,CAACd,KAAL,CAAWmC,OAAX;AAAqB;;AAA2B,UAAM,IAAIE,WAAJ,CAAgB,kBAAhB,CAAN;AACjD,GAFD,CAEE,OAAOtB,CAAP,EAAU;AACV,WAAOC,wBAAwB,CAACD,CAAD,EAAI;AACjCE,MAAAA,OAAO,EAAEF,CAAC,CAACE,OAAF,CAAUqB,OAAV,CAAkB,GAAlB,EAAuBN,IAAvB,CADwB;AAEjCd,MAAAA,KAAK,EAAEH,CAAC,CAACG;AAFwB,KAAJ,CAA/B;AAID;AACF;AAED;;;;;;;;;AAQA,SAASN,SAAT,CAAoBmB,GAApB,EAAyB;AACvB,SAAOnC,iBAAiB,CAAC2C,IAAlB,CAAuBR,GAAvB,EAA4B,CAA5B,CAAP;AACD;AAED;;;;;;;;AAOA,SAASJ,UAAT,CAAqBP,GAArB,EAA0B;AACxB,MAAI;AACF,WAAO,CAAChC,WAAW,CAACY,KAAZ,CAAkBoB,GAAlB,EAAuBoB,UAAvB,CAAkCd,OAAlC,IAA6C,EAA9C,EAAkDe,WAAlD,EAAP;AACD,GAFD,CAEE,OAAO1B,CAAP,EAAU;AACV,WAAO2B,SAAP;AACD;AACF;AAED;;;;;;;;;AAQA,SAAS1B,wBAAT,CAAmC2B,KAAnC,EAA0CC,GAA1C,EAA+C;AAC7C,MAAIC,IAAI,GAAGC,MAAM,CAACC,mBAAP,CAA2BJ,KAA3B,CAAX;;AAEA,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACnC,MAAzB,EAAiCsC,CAAC,EAAlC,EAAsC;AACpC,QAAIC,GAAG,GAAGJ,IAAI,CAACG,CAAD,CAAd;;AACA,QAAIC,GAAG,KAAK,OAAR,IAAmBA,GAAG,KAAK,SAA/B,EAA0C;AACxC,aAAON,KAAK,CAACM,GAAD,CAAZ;AACD;AACF,GAR4C,CAU7C;;;AACAN,EAAAA,KAAK,CAACzB,KAAN,GAAc0B,GAAG,CAAC1B,KAAJ,CAAUoB,OAAV,CAAkBK,KAAK,CAAC1B,OAAxB,EAAiC2B,GAAG,CAAC3B,OAArC,CAAd;AACA0B,EAAAA,KAAK,CAAC1B,OAAN,GAAgB2B,GAAG,CAAC3B,OAApB;AAEA,SAAO0B,KAAP;AACD;AAED;;;;;;;;AAOA,SAASnC,WAAT,CAAsBJ,IAAtB,EAA4B;AAC1B,SAAO,SAAS8C,SAAT,CAAoB9B,GAApB,EAAyB;AAC9B,WAAO+B,OAAO,CAAC3D,MAAM,CAAC4B,GAAD,EAAMhB,IAAN,CAAP,CAAd;AACD,GAFD;AAGD","sourcesContent":["/*!\r\n * body-parser\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar bytes = require('bytes')\r\nvar contentType = require('content-type')\r\nvar createError = require('http-errors')\r\nvar debug = require('debug')('body-parser:json')\r\nvar read = require('../read')\r\nvar typeis = require('type-is')\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = json\r\n\r\n/**\r\n * RegExp to match the first non-space in a string.\r\n *\r\n * Allowed whitespace is defined in RFC 7159:\r\n *\r\n *    ws = *(\r\n *            %x20 /              ; Space\r\n *            %x09 /              ; Horizontal tab\r\n *            %x0A /              ; Line feed or New line\r\n *            %x0D )              ; Carriage return\r\n */\r\n\r\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*(.)/ // eslint-disable-line no-control-regex\r\n\r\n/**\r\n * Create a middleware to parse JSON bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\r\n\r\nfunction json (options) {\r\n  var opts = options || {}\r\n\r\n  var limit = typeof opts.limit !== 'number'\r\n    ? bytes.parse(opts.limit || '100kb')\r\n    : opts.limit\r\n  var inflate = opts.inflate !== false\r\n  var reviver = opts.reviver\r\n  var strict = opts.strict !== false\r\n  var type = opts.type || 'application/json'\r\n  var verify = opts.verify || false\r\n\r\n  if (verify !== false && typeof verify !== 'function') {\r\n    throw new TypeError('option verify must be function')\r\n  }\r\n\r\n  // create the appropriate type checking function\r\n  var shouldParse = typeof type !== 'function'\r\n    ? typeChecker(type)\r\n    : type\r\n\r\n  function parse (body) {\r\n    if (body.length === 0) {\r\n      // special-case empty json body, as it's a common client-side mistake\r\n      // TODO: maybe make this configurable or part of \"strict\" option\r\n      return {}\r\n    }\r\n\r\n    if (strict) {\r\n      var first = firstchar(body)\r\n\r\n      if (first !== '{' && first !== '[') {\r\n        debug('strict violation')\r\n        throw createStrictSyntaxError(body, first)\r\n      }\r\n    }\r\n\r\n    try {\r\n      debug('parse json')\r\n      return JSON.parse(body, reviver)\r\n    } catch (e) {\r\n      throw normalizeJsonSyntaxError(e, {\r\n        message: e.message,\r\n        stack: e.stack\r\n      })\r\n    }\r\n  }\r\n\r\n  return function jsonParser (req, res, next) {\r\n    if (req._body) {\r\n      debug('body already parsed')\r\n      next()\r\n      return\r\n    }\r\n\r\n    req.body = req.body || {}\r\n\r\n    // skip requests without bodies\r\n    if (!typeis.hasBody(req)) {\r\n      debug('skip empty body')\r\n      next()\r\n      return\r\n    }\r\n\r\n    debug('content-type %j', req.headers['content-type'])\r\n\r\n    // determine if request should be parsed\r\n    if (!shouldParse(req)) {\r\n      debug('skip parsing')\r\n      next()\r\n      return\r\n    }\r\n\r\n    // assert charset per RFC 7159 sec 8.1\r\n    var charset = getCharset(req) || 'utf-8'\r\n    if (charset.substr(0, 4) !== 'utf-') {\r\n      debug('invalid charset')\r\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\r\n        charset: charset,\r\n        type: 'charset.unsupported'\r\n      }))\r\n      return\r\n    }\r\n\r\n    // read\r\n    read(req, res, next, parse, debug, {\r\n      encoding: charset,\r\n      inflate: inflate,\r\n      limit: limit,\r\n      verify: verify\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Create strict violation syntax error matching native error.\r\n *\r\n * @param {string} str\r\n * @param {string} char\r\n * @return {Error}\r\n * @private\r\n */\r\n\r\nfunction createStrictSyntaxError (str, char) {\r\n  var index = str.indexOf(char)\r\n  var partial = str.substring(0, index) + '#'\r\n\r\n  try {\r\n    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')\r\n  } catch (e) {\r\n    return normalizeJsonSyntaxError(e, {\r\n      message: e.message.replace('#', char),\r\n      stack: e.stack\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the first non-whitespace character in a string.\r\n *\r\n * @param {string} str\r\n * @return {function}\r\n * @private\r\n */\r\n\r\nfunction firstchar (str) {\r\n  return FIRST_CHAR_REGEXP.exec(str)[1]\r\n}\r\n\r\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\r\n\r\nfunction getCharset (req) {\r\n  try {\r\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\r\n  } catch (e) {\r\n    return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Normalize a SyntaxError for JSON.parse.\r\n *\r\n * @param {SyntaxError} error\r\n * @param {object} obj\r\n * @return {SyntaxError}\r\n */\r\n\r\nfunction normalizeJsonSyntaxError (error, obj) {\r\n  var keys = Object.getOwnPropertyNames(error)\r\n\r\n  for (var i = 0; i < keys.length; i++) {\r\n    var key = keys[i]\r\n    if (key !== 'stack' && key !== 'message') {\r\n      delete error[key]\r\n    }\r\n  }\r\n\r\n  // replace stack before message for Node.js 0.10 and below\r\n  error.stack = obj.stack.replace(error.message, obj.message)\r\n  error.message = obj.message\r\n\r\n  return error\r\n}\r\n\r\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\r\n\r\nfunction typeChecker (type) {\r\n  return function checkType (req) {\r\n    return Boolean(typeis(req, type))\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}