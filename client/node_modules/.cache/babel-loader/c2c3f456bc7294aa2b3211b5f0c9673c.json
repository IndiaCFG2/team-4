{"ast":null,"code":"/*!\r\n * body-parser\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n'use strict';\n/**\r\n * Module dependencies.\r\n * @private\r\n */\n\nvar bytes = require('bytes');\n\nvar contentType = require('content-type');\n\nvar createError = require('http-errors');\n\nvar debug = require('debug')('body-parser:urlencoded');\n\nvar deprecate = require('depd')('body-parser');\n\nvar read = require('../read');\n\nvar typeis = require('type-is');\n/**\r\n * Module exports.\r\n */\n\n\nmodule.exports = urlencoded;\n/**\r\n * Cache of parser modules.\r\n */\n\nvar parsers = Object.create(null);\n/**\r\n * Create a middleware to parse urlencoded bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\n\nfunction urlencoded(options) {\n  var opts = options || {}; // notice because option default will flip in next major\n\n  if (opts.extended === undefined) {\n    deprecate('undefined extended: provide extended option');\n  }\n\n  var extended = opts.extended !== false;\n  var inflate = opts.inflate !== false;\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var type = opts.type || 'application/x-www-form-urlencoded';\n  var verify = opts.verify || false;\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  } // create the appropriate query parser\n\n\n  var queryparse = extended ? extendedparser(opts) : simpleparser(opts); // create the appropriate type checking function\n\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n\n  function parse(body) {\n    return body.length ? queryparse(body) : {};\n  }\n\n  return function urlencodedParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n\n    req.body = req.body || {}; // skip requests without bodies\n\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n\n    debug('content-type %j', req.headers['content-type']); // determine if request should be parsed\n\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    } // assert charset\n\n\n    var charset = getCharset(req) || 'utf-8';\n\n    if (charset !== 'utf-8') {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    } // read\n\n\n    read(req, res, next, parse, debug, {\n      debug: debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n/**\r\n * Get the extended query parser.\r\n *\r\n * @param {object} options\r\n */\n\n\nfunction extendedparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;\n  var parse = parser('qs');\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit);\n\n    if (paramCount === undefined) {\n      debug('too many parameters');\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n\n    var arrayLimit = Math.max(100, paramCount);\n    debug('parse extended urlencoding');\n    return parse(body, {\n      allowPrototypes: true,\n      arrayLimit: arrayLimit,\n      depth: Infinity,\n      parameterLimit: parameterLimit\n    });\n  };\n}\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\n\n\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n/**\r\n * Count the number of parameters, stopping once limit reached\r\n *\r\n * @param {string} body\r\n * @param {number} limit\r\n * @api private\r\n */\n\n\nfunction parameterCount(body, limit) {\n  var count = 0;\n  var index = 0;\n\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++;\n    index++;\n\n    if (count === limit) {\n      return undefined;\n    }\n  }\n\n  return count;\n}\n/**\r\n * Get parser for module name dynamically.\r\n *\r\n * @param {string} name\r\n * @return {function}\r\n * @api private\r\n */\n\n\nfunction parser(name) {\n  var mod = parsers[name];\n\n  if (mod !== undefined) {\n    return mod.parse;\n  } // this uses a switch for static require analysis\n\n\n  switch (name) {\n    case 'qs':\n      mod = require('qs');\n      break;\n\n    case 'querystring':\n      mod = require('querystring');\n      break;\n  } // store to prevent invoking require()\n\n\n  parsers[name] = mod;\n  return mod.parse;\n}\n/**\r\n * Get the simple query parser.\r\n *\r\n * @param {object} options\r\n */\n\n\nfunction simpleparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;\n  var parse = parser('querystring');\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number');\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0;\n  }\n\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit);\n\n    if (paramCount === undefined) {\n      debug('too many parameters');\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      });\n    }\n\n    debug('parse urlencoding');\n    return parse(body, undefined, undefined, {\n      maxKeys: parameterLimit\n    });\n  };\n}\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\n\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":{"version":3,"sources":["C:/Users/nithya/Desktop/team-4/client/node_modules/body-parser/lib/types/urlencoded.js"],"names":["bytes","require","contentType","createError","debug","deprecate","read","typeis","module","exports","urlencoded","parsers","Object","create","options","opts","extended","undefined","inflate","limit","parse","type","verify","TypeError","queryparse","extendedparser","simpleparser","shouldParse","typeChecker","body","length","urlencodedParser","req","res","next","_body","hasBody","headers","charset","getCharset","toUpperCase","encoding","parameterLimit","parser","isNaN","isFinite","paramCount","parameterCount","arrayLimit","Math","max","allowPrototypes","depth","Infinity","parameters","toLowerCase","e","count","index","indexOf","name","mod","maxKeys","checkType","Boolean"],"mappings":"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","sourcesContent":["/*!\r\n * body-parser\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar bytes = require('bytes')\r\nvar contentType = require('content-type')\r\nvar createError = require('http-errors')\r\nvar debug = require('debug')('body-parser:urlencoded')\r\nvar deprecate = require('depd')('body-parser')\r\nvar read = require('../read')\r\nvar typeis = require('type-is')\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = urlencoded\r\n\r\n/**\r\n * Cache of parser modules.\r\n */\r\n\r\nvar parsers = Object.create(null)\r\n\r\n/**\r\n * Create a middleware to parse urlencoded bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\r\n\r\nfunction urlencoded (options) {\r\n  var opts = options || {}\r\n\r\n  // notice because option default will flip in next major\r\n  if (opts.extended === undefined) {\r\n    deprecate('undefined extended: provide extended option')\r\n  }\r\n\r\n  var extended = opts.extended !== false\r\n  var inflate = opts.inflate !== false\r\n  var limit = typeof opts.limit !== 'number'\r\n    ? bytes.parse(opts.limit || '100kb')\r\n    : opts.limit\r\n  var type = opts.type || 'application/x-www-form-urlencoded'\r\n  var verify = opts.verify || false\r\n\r\n  if (verify !== false && typeof verify !== 'function') {\r\n    throw new TypeError('option verify must be function')\r\n  }\r\n\r\n  // create the appropriate query parser\r\n  var queryparse = extended\r\n    ? extendedparser(opts)\r\n    : simpleparser(opts)\r\n\r\n  // create the appropriate type checking function\r\n  var shouldParse = typeof type !== 'function'\r\n    ? typeChecker(type)\r\n    : type\r\n\r\n  function parse (body) {\r\n    return body.length\r\n      ? queryparse(body)\r\n      : {}\r\n  }\r\n\r\n  return function urlencodedParser (req, res, next) {\r\n    if (req._body) {\r\n      debug('body already parsed')\r\n      next()\r\n      return\r\n    }\r\n\r\n    req.body = req.body || {}\r\n\r\n    // skip requests without bodies\r\n    if (!typeis.hasBody(req)) {\r\n      debug('skip empty body')\r\n      next()\r\n      return\r\n    }\r\n\r\n    debug('content-type %j', req.headers['content-type'])\r\n\r\n    // determine if request should be parsed\r\n    if (!shouldParse(req)) {\r\n      debug('skip parsing')\r\n      next()\r\n      return\r\n    }\r\n\r\n    // assert charset\r\n    var charset = getCharset(req) || 'utf-8'\r\n    if (charset !== 'utf-8') {\r\n      debug('invalid charset')\r\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\r\n        charset: charset,\r\n        type: 'charset.unsupported'\r\n      }))\r\n      return\r\n    }\r\n\r\n    // read\r\n    read(req, res, next, parse, debug, {\r\n      debug: debug,\r\n      encoding: charset,\r\n      inflate: inflate,\r\n      limit: limit,\r\n      verify: verify\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the extended query parser.\r\n *\r\n * @param {object} options\r\n */\r\n\r\nfunction extendedparser (options) {\r\n  var parameterLimit = options.parameterLimit !== undefined\r\n    ? options.parameterLimit\r\n    : 1000\r\n  var parse = parser('qs')\r\n\r\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\r\n    throw new TypeError('option parameterLimit must be a positive number')\r\n  }\r\n\r\n  if (isFinite(parameterLimit)) {\r\n    parameterLimit = parameterLimit | 0\r\n  }\r\n\r\n  return function queryparse (body) {\r\n    var paramCount = parameterCount(body, parameterLimit)\r\n\r\n    if (paramCount === undefined) {\r\n      debug('too many parameters')\r\n      throw createError(413, 'too many parameters', {\r\n        type: 'parameters.too.many'\r\n      })\r\n    }\r\n\r\n    var arrayLimit = Math.max(100, paramCount)\r\n\r\n    debug('parse extended urlencoding')\r\n    return parse(body, {\r\n      allowPrototypes: true,\r\n      arrayLimit: arrayLimit,\r\n      depth: Infinity,\r\n      parameterLimit: parameterLimit\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\r\n\r\nfunction getCharset (req) {\r\n  try {\r\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\r\n  } catch (e) {\r\n    return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Count the number of parameters, stopping once limit reached\r\n *\r\n * @param {string} body\r\n * @param {number} limit\r\n * @api private\r\n */\r\n\r\nfunction parameterCount (body, limit) {\r\n  var count = 0\r\n  var index = 0\r\n\r\n  while ((index = body.indexOf('&', index)) !== -1) {\r\n    count++\r\n    index++\r\n\r\n    if (count === limit) {\r\n      return undefined\r\n    }\r\n  }\r\n\r\n  return count\r\n}\r\n\r\n/**\r\n * Get parser for module name dynamically.\r\n *\r\n * @param {string} name\r\n * @return {function}\r\n * @api private\r\n */\r\n\r\nfunction parser (name) {\r\n  var mod = parsers[name]\r\n\r\n  if (mod !== undefined) {\r\n    return mod.parse\r\n  }\r\n\r\n  // this uses a switch for static require analysis\r\n  switch (name) {\r\n    case 'qs':\r\n      mod = require('qs')\r\n      break\r\n    case 'querystring':\r\n      mod = require('querystring')\r\n      break\r\n  }\r\n\r\n  // store to prevent invoking require()\r\n  parsers[name] = mod\r\n\r\n  return mod.parse\r\n}\r\n\r\n/**\r\n * Get the simple query parser.\r\n *\r\n * @param {object} options\r\n */\r\n\r\nfunction simpleparser (options) {\r\n  var parameterLimit = options.parameterLimit !== undefined\r\n    ? options.parameterLimit\r\n    : 1000\r\n  var parse = parser('querystring')\r\n\r\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\r\n    throw new TypeError('option parameterLimit must be a positive number')\r\n  }\r\n\r\n  if (isFinite(parameterLimit)) {\r\n    parameterLimit = parameterLimit | 0\r\n  }\r\n\r\n  return function queryparse (body) {\r\n    var paramCount = parameterCount(body, parameterLimit)\r\n\r\n    if (paramCount === undefined) {\r\n      debug('too many parameters')\r\n      throw createError(413, 'too many parameters', {\r\n        type: 'parameters.too.many'\r\n      })\r\n    }\r\n\r\n    debug('parse urlencoding')\r\n    return parse(body, undefined, undefined, { maxKeys: parameterLimit })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\r\n\r\nfunction typeChecker (type) {\r\n  return function checkType (req) {\r\n    return Boolean(typeis(req, type))\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}